<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flow Matrix Visualization</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
<style>
  body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: #1a1a1a;
    color: white;
    font-family: Arial, sans-serif;
  }
  canvas {
    border: 2px solid white;
  }
</style>
</head>
<body>
<script>
  let size = 7              // Grid size (Adjustable)
  let n = 100               // Total sum to distribute
  let peakMatrix, fillMatrix, queue = []
  let cellSize = 50         // Size of each cell in pixels

  function setup() {
    createCanvas(size * cellSize, size * cellSize)
    peakMatrix = generateRandomPeakMatrix(size)
    // print the peak matrix
    console.log(peakMatrix.map(row => row.join("\t")).join("\n"))
    fillMatrix = Array.from({ length: size }, () => Array(size).fill(0))

    let center = Math.floor(size / 2)
    queue.push([center, center])  // Start filling from center
    frameRate(10)                 // Controls the animation speed
  }

  function draw() {
    background(20)
    drawMatrix()                  // Render matrix visually

    if(n > 0) {
      // distributeFlow()
      distributeFlow(Math.floor(size / 1), Math.floor(size / 2), 10, 1)  // Spreads flow to 2-degree neighbors
    }
  }

  function generateRandomPeakMatrix(size) {
    let matrix = Array.from({ length: size }, () => Array(size).fill(0))
    let center = Math.floor(size / 2)
    let numbers = []

    for (let i = 0; i < size * size; i++) {
      numbers.push(i + 1)
    }
    numbers.sort(() => Math.random() - 0.5)  // Shuffle values

    let queue = [[center, center]]
    let index = 0

    while (queue.length > 0) {
      let [x, y] = queue.shift()
      if (matrix[x][y] === 0) {
        matrix[x][y] = numbers[index++]
      }
      let neighbors = [
        [x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]
      ].filter(([nx, ny]) => nx >= 0 && ny >= 0 && nx < size && ny < size && matrix[nx][ny] === 0)
      neighbors.sort(() => Math.random() - 0.5)
      queue.push(...neighbors)
    }

    return matrix
  }

  function distributeFlow(x, y, amount, degree) {
    let queue = [{ x, y, amount }];

    while (queue.length > 0) {
      let { x, y, amount } = queue.shift();

      if (amount <= 0) continue;  // Stop if no more flow to distribute

      let neighbors = findNeighbors(x, y, degree);

      if (neighbors.length > 0) {
        let share = Math.floor(amount / neighbors.length);
        let remainder = amount % neighbors.length;

        for (let i = 0; i < neighbors.length; i++) {
          let { nx, ny } = neighbors[i];
          if (fillMatrix[nx][ny] < peakMatrix[nx][ny]) {
            let distributeAmount = share + (i < remainder ? 1 : 0);
            fillMatrix[nx][ny] += distributeAmount;
            queue.push({ x: nx, y: ny, amount: distributeAmount });
          }
        }
      }
    }


    function findNeighbors(x, y, degree) {
      let neighbors = [];

      for (let dx = -degree; dx <= degree; dx++) {
        for (let dy = -degree; dy <= degree; dy++) {
          let nx = x + dx;
          let ny = y + dy;

          if (
              (dx !== 0 || dy !== 0) &&  // Exclude the original cell
              nx >= 0 && ny >= 0 &&
              nx < size && ny < size
          ) {
              neighbors.push({ nx, ny });
          }
        }
      }

      return neighbors;
    }

  }


  function drawMatrix() {
    for (let i = 0; i < size; i++) {
      for (let j = 0; j < size; j++) {
        let filledRatio = fillMatrix[i][j] / peakMatrix[i][j]
        let colourValue = map(filledRatio, 0, 1, 50, 255)
        fill(colourValue, 0, colourValue)               // increase/decrease intensity of the colour
        rect(j * cellSize, i * cellSize, cellSize, cellSize)
        
        fill(255)
        textAlign(CENTER, CENTER)
        textSize(14)
        text(fillMatrix[i][j], j * cellSize + cellSize / 2, i * cellSize + cellSize / 2)
      }
    }
  }
</script>
</body>
</html>
